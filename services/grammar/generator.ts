import { BioSentence, InteractionSentence, DefinitionSentence, InitializationSentence, SimulationSentence } from './types';

export class BNGLGenerator {
  static generate(sentences: BioSentence[]): string {
    const definitions = sentences.filter(s => s.type === 'DEFINITION' && s.isValid) as DefinitionSentence[];
    const interactions = sentences.filter(s => s.type === 'INTERACTION' && s.isValid) as InteractionSentence[];
    const initializations = sentences.filter(s => s.type === 'INITIALIZATION' && s.isValid) as InitializationSentence[];
    const simulation = sentences.find(s => s.type === 'SIMULATION' && s.isValid) as SimulationSentence | undefined;

    // Symbol Table: Track defined molecules and their sites/states
    const moleculeMap = new Map<string, { sites: Set<string>, states: Record<string, Set<string>> }>();

    // 1. Process Definitions
    definitions.forEach(def => {
      const { name, sites, states } = def.agent;
      if (!moleculeMap.has(name)) {
        moleculeMap.set(name, { sites: new Set(sites), states: {} });
      }
      const entry = moleculeMap.get(name)!;
      sites.forEach(s => entry.sites.add(s));
      Object.entries(states).forEach(([site, stateList]) => {
        if (!entry.states[site]) entry.states[site] = new Set();
        stateList.forEach(st => entry.states[site].add(st));
      });
    });

    // 2. Infer Sites from Interactions (Implicit Definitions)
    interactions.forEach(int => {
      const subName = int.subject.name;
      const objName = int.object.name;

      [subName, objName].forEach(name => {
        if (!moleculeMap.has(name)) {
          moleculeMap.set(name, { sites: new Set(), states: {} });
        }
      });

      if (int.action === 'binds') {
        // Implicit binding site 'b' if no sites exist, or use 'b' convention
        moleculeMap.get(subName)!.sites.add('b');
        moleculeMap.get(objName)!.sites.add('b');
      } else if (int.action === 'phosphorylates' || int.action === 'dephosphorylates') {
        // Target needs a site that can be phosphorylated. Convention: 'y' or infer site
        // For now, add 'y' and states u, p if not present
        const targetEntry = moleculeMap.get(objName)!;
        targetEntry.sites.add('y');
        if (!targetEntry.states['y']) targetEntry.states['y'] = new Set();
        targetEntry.states['y'].add('u');
        targetEntry.states['y'].add('p');
      }
    });

    // 3. Generate BNGL Blocks
    const lines: string[] = ['begin model'];

    // Parameters (Auto-generated defaults)
    lines.push('begin parameters');
    lines.push('  k_on 0.1');
    lines.push('  k_off 0.1');
    lines.push('  k_cat 1.0');
    lines.push('  k_dephos 1.0');
    // Add explicitly mentioned rates
    interactions.forEach(int => {
      if (int.rate && !['k_on', 'k_cat', 'k_dephos'].includes(int.rate)) {
        if (!isNaN(parseFloat(int.rate))) {
          // It's a number, inline usage is fine, but maybe define param?
          // For strictness, let's just use it inline in rules
        }
      }
    });
    lines.push('end parameters');

    // Molecule Types
    lines.push('begin molecule types');
    moleculeMap.forEach((data, name) => {
      const siteStrParts: string[] = [];
      data.sites.forEach(site => {
        const states = data.states[site];
        if (states && states.size > 0) {
          // e.g. y~u~p
          siteStrParts.push(`${site}~${Array.from(states).join('~')}`);
        } else {
          siteStrParts.push(site);
        }
      });
      lines.push(`  ${name}(${siteStrParts.join(',')})`);
    });
    lines.push('end molecule types');

    // Seed Species
    lines.push('begin species');
    if (initializations.length > 0) {
      initializations.forEach(init => {
        // Simple case: A(all sites unbound/default)
        // Construct default state string
        const name = init.molecule.name;
        const entry = moleculeMap.get(name);
        if (entry) {
          const sitesStr = Array.from(entry.sites).map(s => {
            const states = entry.states[s];
            if (states && states.has('u')) return `${s}~u`;
            if (states && states.size > 0) return `${s}~${Array.from(states)[0]}`; // pick first
            return s;
          }).join(',');
          lines.push(`  ${name}(${sitesStr}) ${init.count}`);
        }
      });
    } else {
      // Default initialization if none provided
      lines.push('  # Default seeds generated by Designer');
      moleculeMap.forEach((_, name) => {
        const entry = moleculeMap.get(name)!;
        const sitesStr = Array.from(entry.sites).map(s => {
          const states = entry.states[s];
          if (states && states.has('u')) return `${s}~u`;
          if (states && states.size > 0) return `${s}~${Array.from(states)[0]}`;
          return s;
        }).join(',');
        lines.push(`  ${name}(${sitesStr}) 100`);
      });
    }
    lines.push('end species');

    // Observables (Simple defaults for now)
    lines.push('begin observables');
    lines.push('  # Auto-generated observables');
    moleculeMap.forEach((_, name) => {
      lines.push(`  Molecules ${name}_tot ${name}()`);
    });
    lines.push('end observables');

    // Reaction Rules
    lines.push('begin reaction rules');
    interactions.forEach((int, idx) => {
      const ruleName = `rule${idx + 1}`;
      if (int.action === 'binds') {
        const s = int.subject.name;
        const o = int.object.name;
        // Assume 'b' site for binding context
        lines.push(`  ${ruleName}: ${s}(b) + ${o}(b) <-> ${s}(b!1).${o}(b!1) ${int.rate}, ${int.reverseRate}`);
      } else if (int.action === 'phosphorylates') {
        const kinase = int.subject.name;
        const target = int.object.name;
        // Kinase assumed to be active/bound? For logic simplicity:
        // Kinase(b) + Target(y~u) -> Kinase(b) + Target(y~p)
        // Note: Needs context! Usually binding first. 
        // For "Grammar", assume Michaelis-Menten-like or simple collision if not binding specified
        // Let's do simple collision for robustness
        lines.push(`  ${ruleName}: ${kinase}() + ${target}(y~u) -> ${kinase}() + ${target}(y~p) ${int.rate}`);
      } else if (int.action === 'dephosphorylates') {
        const phos = int.subject.name;
        const target = int.object.name;
        lines.push(`  ${ruleName}: ${phos}() + ${target}(y~p) -> ${phos}() + ${target}(y~u) ${int.rate}`);
      }
    });
    lines.push('end reaction rules');

    lines.push('end model');
    lines.push('generate_network({overwrite=>1})');

    if (simulation) {
      lines.push(`simulate({method=>"ode", t_end=>${simulation.duration}, n_steps=>${simulation.steps}})`);
    } else {
      lines.push('simulate({method=>"ode", t_end=>100, n_steps=>100})');
    }

    return lines.join('\n');
  }
}
